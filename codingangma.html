<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>codingangma</title>
</head>
<body>
  <p>const : 절대로 바뀌지 않는 상수</p>
  <p>let : 변할 수 있는 값</p>
  <p>변수 첫 글자는 숫자가 될 수 없다, 예약어는 사용할 수 없음</p>
</body>
<script>
const name = "Mike";
const age = 30;

const name1 = `My name is ${name}`
const name2 = "My name is ${name}"
console.log(name1, name2)
console.log(typeof name1) // 다른 개발자가 어떻게 썼는지 찾아 볼 때 typeof 를 사용
//문자형 + 숫자형 = 문자형

//--------------------------------------------

//alert()

//prompt()
// const name3 = prompt("이름을 입력하세요.");
// const name4 = prompt("이름을 입력하세요.", "예 : 홍길동님"); //prompt 는 두가지 인수(default)를 활용할 수 있음
// alert("환영합니다, " + name4 + "님");
// alert(`환영합니다, ${name3}님.`);

//confirm("구독을 취소 하시겠습니까?")
// const isAdult = confirm("당신은 성인 입니까?");

//alert(), prompt(), confirm() 의 단점 : 스크립트 일시 정지, 스타일링 불가

//--------------------------------------------

//명시적 형변환

// String() => 문자형으로 변경
// Number() => 숫자형으로 변경
// Boolean() => 불린형으로 변환

// 형변환이 필요한 이유 

// const mathScore = prompt("수학 몇점?"); 
// const engScore = prompt("영어 몇점?");
//prompt 입력하면 문자형으로 받아옴
const mathScore = 90;
const engScore = 80;
const result = (mathScore + engScore) /2;
console.log(result)

console.log(
String(3),
String(true),
String(false),
String(null),
String(undefined)
)

console.log(
  Number("1234"),
  Number(true),
  Number(false)
)
//true 와 false는 1과 0으로 변환해준다

console.log(
  Boolean(0),
  Boolean(""),
  Boolean(null),
  Boolean(undefined),
  Boolean(NaN)
)
//boolean 은 위 경우만 false가 나오고 그 외에는 전부 true
//Number(null) == 0 *
//Number(undefined) == NaN **
//Number(0) == false ***
//Number('0') == true ****
//Number('') == false *****
//Number(' ') == true 비어있지 않은 문자열도 true ******

//--------------------------------------------
//연산자(Operators)
//% --> 나눈 나머지 값을 구해옴
const num6 = 2**3;
console.log(num6) // 거듭제곱
let num = 10;
let result3 = num++;
let result2 = ++num;
console.log(result2,result3) // ++가 뒤에 붙으면 계산하기 이전의 값을 반환

//--------------------------------------------
//비교 연산자, 조건문
console.log(10 > 5);
console.log(10 == 5);
console.log(10 != 5); //조건문은 true 와 false 값만 반환한다
const age1 = 19;
if(age1>19){
  console.log('환영합니다.');
}else if(age1===19){
  console.log('수능 잘치세요.')
}else{
  console.log('안녕히가세요.')
}

//--------------------------------------------
//논리 연산자
// || (OR) or는 첫번째 true를 발견하는 즉시 평가를 멈춤
// && (AND) and는 첫번째 false를 발견하는 즉시 평가를 멈춤
// ! (NOT)

const name3 = "Mike";
const age3 = 30;

if(name === 'Tom' || age > 19){
  console.log('통과');
}
if(name === 'Tom' && age > 19){
  console.log('통과');
}else{
  console.log('돌아가.');
}

// const age4 = prompt('나이가..?')
// const isAge = age4 > 19;
// if(!isAge){
//   console.log('돌아가..')
// }

const gender = 'F'
const name4 = 'Jane'
const isAdult = true;

if(gender === 'M' && name4 === 'Mike' || isAdult){
  //AND(||)가 OR(&&)보다 우선 순위가 높다
  console.log('통과')
}else{
  console.log('돌아가')
}

//--------------------------------------------
//반복문 loop : 동일한 작업을 여러번 반복
for (let i = 0; i <= 10; i++){
  //반복할 코드
  console.log(i)
}
let i = 0;
while(i < 10){
  console.log(i);
  i++;
}
let i2 =0;
do{
  i2++;
}while(i2<12) //반복문을 한 번은 실행한다는 점에서 while과 다름
console.log(i2);
//--------------------------------------------
//break : 멈추고 빠져나옴 continue : 멈추고 다음 반복으로 진행
function whileBreak(){
  while(true){ //while(true)는 무한 반복되므로 주의
    let answer = confirm('계속 할까요?');
    if(!answer){
      break;
    }
  }
}
// whileBreak()
for(let i = 0; i < 10; i++){
  if(i%2){
    continue;
  }
  console.log(i)
} //명확한 횟수가 정해져 있으면 for, 아니면 while.

//--------------------------------------------
//switch 
function switch2(){
  let fruit = prompt('무슨 과일을 사고 싶나요?');
  switch(fruit){
    case '사과' :
      console.log('100원 입니다.');
      break;
    case '바나나' :
      console.log('200원 입니다.');
      break;
    case '딸기' :
      console.log('300원 입니다.');
      break;
    case '키위' :
      console.log('400원 입니다.');
      break;
    case '수박' :
      console.log('500원 입니다.');
      break;
    case '망고' :
      console.log('600원 입니다.');
      break;
    default:
      console.log('그런 과일은 없습니다.');
  }
}
// switch2();
function showError(){//매개변수는 두개 이상 쉼표로 작성 가능
alert('에러가 발생했습니다. 다시 시도해주세요');
}
// showError();
let msg = `hellow, `;
function sayHellos(name){  
  if(name){
    // msg = `hello, ${name}`
    msg += ', ' + name;
  }  
}
sayHellos('Mike');
sayHellos('Tom');
sayHellos('Jane'); // 함수를 한 번 만들어 놓으면 매개변수를 바꿔가면서 다양하게 대응 가능
sayHellos();
console.log(msg)
//매개변수의 기본값 설정
function sayHello(name = 'friend'){
  // let newName = name || 'friend'
  let msg = `Hello, ${name}`
  console.log(msg)
}
sayHello()
sayHello('Jane')
//return 으로 값 변환
function add(num1, num2){
  return num1 + num2;
}
const result4 = add(2,3);
console.log(result4)
function showError2(){
  alert('에러가 발생했습니다.');
  return;
  alert('이 코드는 절대 실행되지 않습니다.')
}
// showError2();
// 함수는 한 번에 한 작업에 집중
// 읽기 쉽고 어떤 동작인지 알 수 있게 네이밍


//--------------------------------------------
//함수 선언문 vs 함수 표현식
//함수 선언문 : 어디서든 호출 가능! 인터프리터 언어인 자바스크립트 환경에서도, 위에서 호출해도 사용 가능
//자바스크립트는 실행 전 초기화 단계에서 모든 함수 선언문을 생성해 놓음(호이스팅)
//함수 선언문이 더 좋음
function sayHello2(){
  console.log('Hello');
}
sayHello2 ();
//함수 표현식
let sayHello3 = function(){
  console.log('Hello');
}
sayHello3 ();

//--------------------------------------------
//화살표 함수(arrow function)

let add1 = function(num1, num2){
  return num1 + num2;
}
let add4 = (num1, num2) => {
  return num1 + num2;
}//function 대신 =>
let add5 = (num1, num2) => (
  num1 + num2
)//코드 본문이 한 줄이기에 이렇게 바꿀 수 있음. return 생략, 중괄호 > 일반괄호
let add6 = (num1, num2) =>  num1 + num2;
//리턴문이 한 줄이면 괄호도 생략 가능
let sayHello4 = name => `Hello, ${name}`;
//인수가 하나라면 괄호 생략 가능
let showError3 = () => {alert('error!');}
//인수가 없는 함수라면 괄호 생략 불가능
let add2 = function(num1,num2){
  const result = num1 + num2;
  return result;
} //리턴문이 있다고 해도 리턴전에 여러줄의 코드가 있을 경우 일반괄호 사용 불가
let add3 = (num1,num2) => {
  const result = num1 + num2;
  return result
} //바로 위 함수는 이렇게 바꿔주어야 함
function test(){
  const add1 = function(num1, num2){
    const result = num1 + num2;
    return result;
  } //↓
  const add2 = (num1, num2) => {
    const result = num1 + num2;
    return result;
  } //↓
  const add3 = (num1, num2) => {
    return num1 + num2;  
  } //↓
  const add4 = (num1, num2) => ( num1 + num2 )
  //↓
  const add5 = (num1, num2) => num1 + num2;
}

//--------------------------------------------
//Object - 단축 프로퍼티

const name5 = 'clark';
const age4 = 33;
const superman = {
  name5:name5,
  age4:age4,
  gender:'male',
}//↓
const superman2 = {
  name5,
  age4,
  gender:'male',
}
//Object - 프로퍼티 존재 여부 확인
superman.birthday; //undefined
'birthday' in superman; //false
'age4' in superman; //true

for(let key in superman){
  console.log(key)
  console.log(superman[key])
}

const batman = {
  name:'clark',
  age:30,
}
console.log(batman.name)
console.log(batman['age'])
batman.hairColor = 'black';
batman['hobby'] = 'footbal';
delete batman.age;
console.log(batman)

function makeObject(name, age){
  return{
    name: name,
    age: age,
    hobby: 'football'
  }
}
function makeObject2(name, age){
  return{
    name,
    age,
    hobby: 'football'
  }
}

const Mike = makeObject2('Mike', 30);
console.log(Mike);
console.log("age" in Mike); //true
console.log("birthday" in Mike); //false

function isAdult2(user){
  if(!('age' in user) || user.age < 20){ //user에 age가 없거나 20살 미만이거나.
    return false;
  }
  return true;  
}

const Nike = {
  name: 'Nike',
  age:30
}

const Jine = {
  name: 'Jine',  
}

console.log(isAdult2(Jine),isAdult2(Nike))

for(x in Nike){
  console.log(x) //name age
  console.log(Nike[x]) // name Nike age 30
}


//--------------------------------------------
//Object - method: 객체 프로퍼티로 할당 된 함수
const antman = {
  name: 'ant',
  age: 33,
  // fly:function(){
    // console.log('날아갑니다.')
  // }
  fly(){ //function 생략 가능
    console.log('날아갑니다.')
  }
}
antman.fly();

const user2 = {
  name:'Mike',
  sayHello:function(){
    console.log(`Hello, I'm ${this.name}`);
  }
}
user2.sayHello();
let boy = {
  name:'Madman',
  sayHello5:function(){
    console.log(`Hello, I'm ${this.name}`);
  }
}
let girl = {
  name:'Jane',
  sayHello5:function(){
    console.log(`Hello, I'm ${this.name}`);
  }
}
boy.sayHello5();
girl.sayHello5();
//화살표 함수는 일반 함수와는 달리 자신만의 this를 가지지 않음
//화살표 함수 내부에서 this를 사용하면, 그 this는 '외부'에서 값을 가져옴

//--------------------------------------------
//this

let boy2 = {
  name:'Maman',
  showName:function(){
    console.log(this.name);
  }
}
let man = boy2;
// man.name = "TOM"
boy2 = null;
man.showName()
// 화살표함수로 메소드를 작성하면 this는 window(전역개체)를
// 가르키게 된다. 때문에 객체의 메소드를 작성할 때는 화살표 함수를
// 사용하지 않는게 좋다.
// boy2.showName();

//--------------------------------------------
//Array
//배열의 특징 : 배열은 문자 뿐만 아니라 숫자, 객체, 함수등도 포함할 수 있다.
//length : 배열의 길이 
//push() : 배열 끝에 추가
//pop() : 배열 끝 요소 제거
//shift(), unshift() : 배열 앞에 제거/추가
//배열을 쓰는 가장 큰 이유는 반복 때문

let days = ['월','화','수'];
for(let index=0; index < days.length; index++){
  console.log(days[index])
}
for(let on of days){
  console.log(on)
  //for...of문은 for문보다 간단하지만
  //index를 못 얻는다는 단점이 있다.
}
let days2 = ['mon','tue','wed'];
days2[2] = '화요일'
console.log(days2)
</script>
</html>