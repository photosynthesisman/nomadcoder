<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>codingangma 자바스크립트 중급 강좌</title>
</head>
<body>
  
</body>
<script>
  function User(name, age){
    this.name = name;
    this.age = age;
    this.sayName = function(){
      console.log(this.age);
    }
  }
  let user5 = new User('Han', 40)
  user5.sayName();

  function Item(title, price){
    //this = {};
    this.title = title;
    this.price = price;
    this.showPrice = function(){
      // console.log(`가격은${price}원 입니다.`);
    }
  }

  const item1 = new Item('인형', 3000);
  const item2 = new Item('가방', 4000);
  const item3 = new Item('지갑', 9000);

  console.log(item1, item2, item3);

  item3.showPrice();

  //--------------------------------------------
  //Computed property (계산된 프로퍼티)

  let a = 'age';
  const user = {
    name:'Mike',
    [a] : 30 
  }
  console.log(user)

  //--------------------------------------------
  //Methods

  //Object.assign():객체 복제
  const newUser = Object.assign({}, user);
  newUser.name = 'Tom';
  newUser != user  
  Object.assign({gender:'male'}, user)

  const user2 = {name:'Mike'}
  const info1 = {age:30,}
  const info2 = {gender:'male',}
  
  Object.assign(user2, info1, info2)
  console.log(user2)

  //Object.values():값 배열 반환
  const user3 = {
    name: 'Mine',
    age : 30,
    gender : 'male',
  }
  Object.values(user3)
  console.log(Object.values(user3))

  //Object.entries():키/값 배열 반환
  const user4 = {
    name : 'MMM',
    age : 30,
    gender: 'male',
  }
  Object.entries(user4)
  console.log(Object.entries(user4))

  //Object.fromEntries() : 키/값 배열을 객체로 **
  const arr = [
    ["name","MIke"],
    ["age",30],
    ["gender","male"]
  ];
  Object.fromEntries(arr);
  console.log(Object.fromEntries(arr))

  let n = "name";
  let b = "age";

  const user6 = {
    [n]: "Mike",
    [b]: 40,
    [1 + 4]: 5,
  };
  console.log(user6)

  function makeObj(key, val){
    return {
      [key] : val,
    };
  }
  const obj = makeObj("나이", 33);
  console.log(obj)

  const user7 = {
    name : "Mike",
    age : 34,
  };

  const user8 = Object.assign({},user7);  
  user8.name = "Tom";

  console.log(user7)
  console.log(user8)
  const result = Object.keys(user7);
  const result2 = Object.values(user7);
  const result3 = Object.entries(user7);
  console.log(result)
  console.log(result2)
  console.log(result3)
  
  let arr2 = [
    ['mon', '월'],
    ['tue', '화'],
  ];
  const result4 = Object.fromEntries(arr2);
  console.log(result4)

  //property key : 문자형

  const obj2 = {
    1:'1입니다.',
    false : '거짓'
  }
  console.log(Object.keys(obj2))

  //Symbol === 유일한 식별자를 만들 때 사용  
  const e = Symbol();
  const f = Symbol();
  console.log(e)
  Symbol()
  console.log(f)
  Symbol()

  const id = Symbol('id');
  const id2 = Symbol('id');
  console.log(id)
  console.log(id2)

  //property key : 심볼형
  const id3 = Symbol('id');
  const user9 = {
    name : 'Mice',
    age : 30,
    [id] : 'myid'
  }
  console.log(Object.keys(user9))
  console.log(Object.values(user9))
  console.log(Object.entries(user9))

  const user10 = {
    name : 'MMM',
    age : 30
  }
  const id4 = Symbol('id');
  user10[id4] = 'myid';

  console.log(user10)
  
  //Symbol.for() : 전역 심볼
  //하나의 심볼만 보장받을 수 있음
  //없으면 만들고, 있으면 가져오기 때문
  //Symbol 함수는 매번 다른 Symbol 값을 생성하지만,
  //Symbol.for 메소드는 하나를 생성한 뒤 키를 통해 같은 Symbol을 공유
  
  const id5 = Symbol.for('id');
  const id6 = Symbol.for('id');

  console.log(id5, id6)

  //description 
  
  const id7 = Symbol('id 입니다.');
  id7.description;
  console.log(id7)
  console.log(id7.description)

  //숨겨진 Symbol key 보는 법

  const id8 = Symbol('id') ;
  const user11 = {
    name : 'MJNN',
    age : 30,
    [id] : 'myid'
  }

  console.log(Object.getOwnPropertySymbols(user11))
  console.log(Reflect.ownKeys(user11))

  //다른 개발자가 만들어 놓은 객체
  const user12 = {
    name: "mna",
    age: 30,
  };
  //내가 작업
  //user.showName = function(){};
  const showName = Symbol("show name");
  user[showName] = function(){
    console.log(this.name);
  };

  user[showName]();

  //사용자가 접속하면 보는 메세지
  for(let key in user){
    console.log(`his ${key} is ${user[key]}.`)
  }
  
  //Symbol을 쓰는 이유 > 다른 사람이 만들어 놓은 property를 덮어 쓸 필요가 없다

  //toString()
  //10진수 > 2진수/16진수 
  let num = 10;
  num.toString(); // "10"
  num.toString(2); // "1010"
  let num2 = 255;
  num2.toString(16); // "ff"

  console.log(Math.PI)
  Math.ceil() //올림
  Math.floor() //내림
  Math.round() //반올림
  
  //소수점 자릿수 toFixed() ** 문자열을 반환하므로 Number로 숫자로 바꿔줘야한다
  let userRate = 30.1234;
  console.log(userRate.toFixed(2)) //소수점 두번째까지 
  console.log(userRate.toFixed(0)) //정수로 반환
  console.log(userRate.toFixed(6)) //나머지는 00으로 반환 
  // ** 문자열을 반환하므로 Number로 숫자로 바꿔줘야한다  
  console.log(typeof(Number(userRate.toFixed(2)))) //number
  console.log(typeof(userRate.toFixed(2))) //string

  //isNaN()

  let x = Number('x'); //NaN

  // x == NaN >> false
  // x === NaN >> false
  // Nan == NaN >> false
  // isNaN(x)>> true
  // isNaN(3)>> false

  //parseInt()
  //문자열을 숫자로 바꿔준다
  //Number()와 다른 점은 문자가 혼용되어 있어도 작동한다.(읽을 수 있는 부분까지)

  let margin = '10px';
  console.log(parseInt(margin)) // 10
  console.log(Number(margin)) // NaN
  let redColor = 'f3';
  console.log(parseInt(redColor)) // NaN
  console.log(parseInt(redColor, 16)) // 243 16진수로 변환
  console.log(parseInt('11', 2)) // 3 2진수에서 10진수로 변환

  //parseFloat()
  //부동소숫점을 반환한다.

  let padding = '18.5%';
  console.log(parseInt(padding)) //18
  console.log(parseFloat(padding)) //18

  //Math.random() 0~1 사이 무작위 숫자 생성
  //1~100 사이의 임의의 숫자를 뽑고 싶다면
  console.log(Math.floor(Math.random()*100)+1)

  //Math.max() 최대값
  //Math.min() 최소값
  console.log(Math.max(1,4,-1,5,10,9,5.54))
  console.log(Math.min(1,4,-1,5,10,9,5.54))
  //Math.abs() 절대값
  console.log(Math.abs(-1))
  //Math.pow(n,m) : n의 m승 값
  console.log(Math.pow(2,10))
  //Math.sqrt() : 제곱근
  console.log(Math.sqrt(16))

  //STRING
  let html = '<div class="box_title">제목 영역</div>';
  let desc = "It's 3 o'clock."
  let name = 'Mike';
  let result5 = `My name is ${name}.`
  let add = `2 더하기 3은 ${2+3}입니다.`
  console.log(html, desc, result5, add )
  //백틱(``)을 사용해서 여러 줄의 문자열 작성하기
  let desc2 = `오늘은 맑고 화창한
  날씨가 계속되겠습니다.
  내일은 비소식이 있겠습니다.`;

  let desc3 = '\n오늘은\n 맑고 화창한\n날시가 계속 되겠습니다.';  
  console.log(desc2, desc3) //백틱을 사용하지 않을 경우 다음과 같이 \n 을 사용해서 줄 넘김

  //length : 문자열 길이
  let desc4 = '안녕하세요.';
  console.log(desc4.length)
  //특정 위치에 접근
  let desc5 = '안녕하세요.';
  console.log(desc5[0])
  console.log(desc5[1] = '난') // 한글자만 바꾸는 건 되지 않음.
  console.log(desc5[0])
  
  //toUpperCase()/toLowerCase() 대문자로/소문자로

  //str.indexOf(text)

  let desc6 = "Hi guys. Nice to meet you.";
  console.log(desc6.indexOf('to'))
  console.log(desc6.indexOf('man')) // 찾는 문자가 없으면 -1을 반환
  //주의할 점은 포함된 문자가 여러개라도 첫 번째 '위치'만 반환한다.
  if(desc6.indexOf('Hi') > -1){ //-1로 비교해줘야 한다
    console.log('Hi가 포함된 문장입니다');
  }

  //str.slice(n,m) n : 시작점 m : 없음면 문자열 끝까지, 양수면 그 숫자 이전까지. 음수면 끝에서부터 센다

  let desc7 = "abcdefg";
  console.log(desc7.slice(2))
  console.log(desc7.slice(0,5))
  console.log(desc7.slice(2,-2))

  //str.substring(n,m) : n과 m사이의 문자열을 반환하며 음수를 반영하지 않는다
  console.log(desc7.substring(0,2))
  //str.substr(n,m) : n부터 시작해서, m개를 가져오는 형태
  console.log(desc7.substr(0,2))

  //str.trim() : 앞 뒤 공백 제거

  let desc8 = "  coding        ";
  console.log(desc8)
  console.log(desc8.trim())

  //str.repeat(n) : n번 반복
  let hello = "hello!";
  console.log(hello.repeat(3))

  //문자열 비교
  //1<3 처럼 //"a" < "c"도 가능

  let list = [
    "01, 들어가며",
    "02, 들어가며",
    "03, 들어가며",
    "04, 들어가며",
    "05, 들어가며",
  ];
  let newList = [];
  //이 배열에서 숫자를 자르고 문자열만 나오게끔
  for(let i = 0; i<list.length; i++){
    newList.push(list[i].slice(4));
  }
  console.log(newList)

  //금칙어 : 콜라

  // function hasCola(str){
  //   if(str.indexOf('콜라') > -1){
  //     console.log('금칙어가 있습니다');
  //   }else{
  //     console.log('통과')
  //   }
  // }
  function hasCola(str){
    if(str.includes ('콜라')){
      console.log('금칙어가 있습니다');
    }else{
      console.log('통과')
    }
  }

  hasCola("와 사이다가 짱이야!");
  hasCola("무슨 소리, 콜라가 최고!");
  hasCola("콜라");

  //--------------------------------------------
  //Array 배열 추가 메소드
  //arr.splice(n, m) : 특정 요소 지움. n부터 m개를 지우게끔
  
  let arr3 = [1,2,3,4,5];
  arr3.splice(1,2);
  console.log(arr3) //[1,4,5]  

  //arr.splice(n,m,x) : 특정 요소 지우고 추가

  let arr4 = [1,2,3,4,5];
  arr4.splice(0,5,6,7,8,9,10);
  console.log(arr4) // [6,7,8,9,10]

  let arr5 = ["나는", "철수", "입니다"];
  arr5.splice(1,0, "대한민국", "소방관"); //(n,m,x)에서 m값을 0으로 설정할 경우 아무것도 지우지 않고 뒤쪽에 배열값 추가
  console.log(arr5)

  //arr.splice() : 삭제된 요소 반환

  let arr6 = [1,2,3,4,5];
  let result6 = arr.splice(1,2);

  //arr.slice(n,m) : n부터 m까지 반환

  console.log(arr6.slice(1,5))

  //arr.concat(arr2, arr3 ..) : 합쳐서 새 배열 반환
  let arr7 = [1,2];
  // console.log(arr7.concat([3,4]));
  // console.log(arr7.concat([3,4],[5,6]));
  // console.log(arr7.concat([3,4,5,6]));
  console.log(arr7.concat([3,4],5,6));

  //arr.forEach(fn) : 배열 반복
  
  let users = ['Mike','Tom','Jane'];
  users.forEach((name, index) => {
    console.log(`${index + 1}, ${name}`)
  })

  //arr.indexOf / arr.lastIndexOf
  let arr8 = [1,2,3,4,5,1,2,3];
  console.log(arr8.indexOf(2)) //2를 찾아서 index 값을 반환
  console.log(arr8.lastIndexOf(2)) //2를 뒤에서 부터 찾았을 때의 index 값을 반환
  console.log(arr8.indexOf(3,3)) //eq(3)부터 3을 찾아서 index 값을 반환
  
  //arr.includes() : 포함하는지 확인
  console.log(arr8.includes(3)); //true
  console.log(arr8.includes(10)); //false
  
  //arr.find(fn) / arr.findIndex(fn)
  //첫번째 true 값만 반환하고 끝, 만약 없으면 undefined를 반환

  let arr9 = [1,2,3,4,5,6,7,8,9,10];
  const result7 = arr9.find((item) => {
    return item % 2 === 0;
  }); //첫번째 true 값만 반환하고 끝, 만약 없으면 undefined를 반환

  console.log(result7)

  let userList = [
    { name : "Mike", age : 30 },
    { name : "Jane", age : 20 },
    { name : "Tom", age : 10 },
  ];

  const result8 = userList.find((user)=>{
    if(user.age < 19){
      return true;
    }
    return false;
  });
  const result9 = userList.findIndex((user)=>{
    if(user.age < 19){
      return true;
    }
    return false;
  });

  console.log(result8)
  console.log(result9)

  //조건을 만족하는 모든 값을 알고 싶다면 find가 아닌 filter사용
  //arr.filter(fn)
  let arr10 = [1,2,3,4,5,6,7,8,9,10];
  const result10 = arr9.filter((item) => {
    return item % 2 === 0;
  }); 
  console.log(result10) // compare to 443
  //arr.reverse() : 역순으로 재정렬
  let arr11 = [1,2,3,4,5];
  console.log(arr11.reverse());

  //arr.map(fn)
  //함수를 받아 특정 기능을 시행하고 새로운 배열을 반환 *** 실무에서 정말 자주 사용되므로
  //연습할 것

  let userList2 = [
    { name:"MNA", age:30 },
    { name:"BBA", age:27 },
    { name:"GEN", age:10 },
  ];

  let newUserList2 = userList2.map((user, index) => {
    return Object.assign({}, user, {
      id: index + 1,
      isAdult: user.age > 19,
    });
  });

  console.log(newUserList2)

  //join 배열을 합쳐서 문자열을 만들 때
  let arr12 = ["안녕", "나는", "철수야"];
  let result11 = arr12.join("-");
  console.log(result11)
  //split 문자열을 나눠서 배열로 만들 때
  const users2 = "Mike,Jane,Tom,Tony";
  const result12 = users2.split(",");
  console.log(result12)
  //split 을 공백으로 나누면 각 단어별로 나누어서 배열로 만들어 준다
  let str = "Hello, My name is Mike.";
  const result13 = str.split("");
  console.log(result13)

  //Array.isArray() 배열인지 아닌지 확인할 때
  
  let user13 = {
    name:"Mike",
    age: 30,
  };
  let userList3 = ["Mike", "Tom", "Jane"];
  console.log(typeof user13);
  console.log(typeof userList3); //typeof로는 구분할 수 없다
  console.log(Array.isArray(user13)); //false
  console.log(Array.isArray(userList)); //true 

  //arr.sort() 배열을 재정렬, 배열 자체가 변경되니 주의
  let arr13 = [1,5,4,3,2,];
  console.log(arr13.sort())
  let arr14 = ["a","c","d","e","b"];
  console.log(arr14.sort())
  let arr15 = [21,85,34,13,2,];
  console.log(arr15.sort()) // [13, 2, 21, 34, 85] 앞자리 인수만 받아서 정렬하기 때문에 정렬이 엉망이다
  function fn(a,b){
    console.log(a,b)
    return a - b;
  }
  console.log(arr15.sort(fn)) // [2, 13, 21, 34, 85]
  //이렇게 함수 넣어주기 복잡하기 때문에 Lodash 라이브러리를 사용한다. ***정말 많이 쓴다.
  //arr.reduce() 인수로 함수를 받음 (누적 계산값, 현재값) => { return 계산값 };

  let arr16 = [1,2,3,4,5];
  //배열의 모든 수 합치기
  let result14 = 0;
  arr16.forEach((num) => {
    result14 += num;
  });
  console.log(result14);
  
  const result15 = arr16.reduce((prev, cur)=>{
    return prev + cur;
  }, 0) //여기서 0은 초기값이고, 지정하지 않으면 배열의 첫번째 요소가 들어간다
  console.log(result15);

  let userList4 = [
    { name : "MNAGE", age : 30 },
    { name : "QNA", age : 13 },
    { name : "SNAOM", age : 23 },
    { name : "TNA", age : 35 },
    { name : "ANAST", age : 40 },
    { name : "DNAUN", age : 60 },
  ];
  //배열 중 나이가 29 이상인 사람
  let result16 = userList4.reduce((prev, cur)=>{ //prev == 계산된 값, cur == 현재 값
    if(cur.age > 29){
      prev.push(cur.name);
    }
    return prev;
  }, [])
  console.log(result16)
  //배열의 모든 나이값 더하기
  let result17 = userList4.reduce((prev, cur)=>{    
    return (prev += cur.age);
  }, 0);  
  console.log(result17)
  //배열 중 이름의 길이가 세글자인 사람
  let result18 = userList4.reduce((prev, cur) => {
    if(cur.name.length === 3){
      prev.push(cur.name);
    }
    return prev;
  }, []);
  console.log(result18)

  //----------------------------------------------------------------------------------------
  //Destructuring assignment 구조 분해 할당 구문
  //구조 분해 할당 구문은 배열이나 객체의 속성을 분해해서 그 값을 변수에 담을 수 있게 하는 표현식

  //배열 구조 분해
  let [X, y] = [1, 2];
  console.log(X); //1
  console.log(y); //2
  let users3 = ['Mike', 'Tom', 'Jane'];
  let [user_1, user_2, user_3] = users3;
  console.log(user_1, user_2, user_3);
  let str2 = "Mikes-Toms-Janes";
  let [user__1, user__2, user__3] = str2.split('-');
  console.log(user__1, user__2, user__3);

  //배열 구조 분해 : 기본값
  let [a_,b_,c_] = [1,2]; //여기서 c_는 undefined
  let [a__=3, b__=4, c__=5] = [1,2];
  console.log(a__, b__, c__)

  //배열 구조 분해 : 일부 반환값 무시
  let [user1_1, ,user2_1] = ['Mike','Tom','Jane','Tony']; //공백과 쉼표를 사용하여 필요하지 않은 배열 요소를 무시할 수 있음
  console.log(user1_1, user2_1);

  //배열 구조 분해 : 바꿔치기
  let aa = 1;
  let bb = 2;
  [aa, bb] = [bb, aa]
  console.log(aa, bb) // aa = 2 bb == 1

  //객체 구조 분해
  let user14 = { name2 : 'MII', age2 : 30 };
  // let { name2, age2 } = user14;
  // console.log(name2, age2)

  //객체 구조 분해 : 새로운 변수 이름으로 할당
  // let { name2: userName, age2: userAge} = user14;
  // console.log(userName, userAge)

  //객체 구조 분해 : 기본값
  // let { name2, age2, gender } = user14;
  let { name2, age2, gender='male'} = user14;
  console.log(user14)
</script>
</html>